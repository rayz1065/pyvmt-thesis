\chapter{VMT-LIB support}
PyVmt modelling system is similar to that of VMT-LIB so that it may easily convert a model to and from VMT-LIB.
This allows for higher interoperability since a model created in PyVmt may be serialized to VMT-LIB and be used in a model checker which isn't supported by the library.

\section{Reading}
PySMT already supports parsing SmtLib2 through the SmtLibParser class.
PyVmt defines a function for reading a script from an input stream called `read', which parses the script and runs through the annotations.
For every NEXT annotation a new state variable is added. Since PyVmt only keeps track of curr state variables the next state one is ignored.
After that, any declaration which was not a curr or next state variable is considered as an input.

To make next state variables work properly in trans constraints and properties, a substituter is employed to replace every instance of a next state variable with the corresponding representation using the Next operator.

Reading an existing VMT-LIB model can have several use-cases:
\begin{enumerate}
    \item Modifying a model by adding state variables or constraints in a programmatic way, or combining it with other models
    \item Analyzing an existing model (e.g. by creating a custom formula walker that reads the constraints, by printing some statistics,\dots)
    \item Running the same VMT-LIB script against multiple solvers, with different combination of options
    \item PySmt's SmtLibParser shows exactly where parsing errors occur, helping debug broken VMT-LIB files. This can be demoed by running \mintinline{bash}{python3 -m pyvmt < some_script.vmt}
\end{enumerate}
\inputminted[firstline=11, lastline=34]{python3}{py/vmtlib_support.py}

\section{Writing}
PySMT already provides printers for SMT-LIB2 supporting two formats: normal and daggified, the latter providing a version that avoids repeating repeated formulae.

The serialize method of the Model produces a fresh symbol for each of the current state variables so that it may use them to replace all of the Next operators which are not supported in VMT-LIB.
To make sure that the replacements work properly, a custom walker named NextPusher is used to push all of the Next operators down to the leaves, leaving Next operators only on Symbols.
Additionally, to replace the unsupported operators the VmtLibSubstituter is used. To be specific it performs a replacement of any Next state variable with the corresponding fresh symbol, leaving the final formula with only supported operators.

As previously mentioned, serializing a model to VMT-LIB is useful whenever trying to use a model checker which is not directly supported by PyVmt, but it can also be a step to use a model checker that doesn't support VMT-LIB in the first place.
Once the model has been serialized to VMT-LIB, several tools are available to further convert the model to a different format, they may be found on the vmt-lib website under the section `Tool Support' \cite{VMT-LIB}, the currently supported formats for conversion are:
\begin{itemize}
    \item btor2
    \item horn
    \item nuXmv
    \item core vmt, excluding language extensions
\end{itemize}

\inputminted[firstline=37, lastline=38]{python3}{py/vmtlib_support.py}

\section{LTL}
PyVmt supports reading LTL-properties thanks to an extension of the SmtLibParser that adds the various operators as interpreted functions. Additionally, LTL operators may be printed using the VmtPrinter and VmtDagPrinter, which respectively extend the SmtPrinter and SmtDagPrinter provided by pySMT. The \begin{math}\phi\ R\ \psi\end{math} operator is not natively supported by VMT-LIB, properties that contain it must first be passed through the VmtLibSubstituter which replaces it with the equivalent \begin{math}\lnot (\lnot \phi\ U \lnot \psi) \end{math}. As mentioned in the previous section this is done automatically while serializing a model.

% LTL removal

