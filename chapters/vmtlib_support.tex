\chapter{VMT-LIB support}
PyVmt modelling system is similar to that of VMT-LIB so that it may easily convert a model to and from VMT-LIB.
This allows for higher interoperability since a model created in PyVmt may be serialized to VMT-LIB and be used in a model checker which isn't supported by the library.

\section{Reading}
PySMT already supports parsing SmtLib2 through the SmtLibParser class.
The only required additions on the parsing side were the various LTL operators which needed to be added as interpreted functions.
PyVmt defines a function for reading a script from an input stream called `read', which parses the script and runs through the annotations.
For every NEXT annotation a new state variable is added, since PyVmt only keeps track of curr state variables the next state one is ignored.
After that, any declaration which was not a curr or next state variable is considered as an input.
To make next state variables work properly in trans constraints and properties, a substituter is used to replace every instance of a next state variable with the corresponding representation using the Next operator.

Reading an existing VMT-LIB model can have several use-cases:
\begin{enumerate}
    \item Modifying a model by adding state variables or constraints in a programmatic way, or combining it with other models
    \item Analyzing an existing model (e.g. by creating a custom formula walker that reads the constraints, by printing some statistics,\dots)
    \item Running the same SMT-LIB script against multiple solvers with different combination of options
    \item PySmt's SmtLibParser shows exactly where parsing errors occur, helping debug broken VMT-LIB files. This can be demoed by running \mintinline{bash}{python3 -m pyvmt < some_script.vmt}
\end{enumerate}
\inputminted[firstline=10, lastline=33]{python3}{py/vmtlib_support.py}

\section{Writing}



\section{LTL}
