\chapter{VMT-LIB support}

\section{The VMT-LIB format}
VMT-LIB is an extension of the SMT2 format and provides a standard interface for defining transition systems by exploiting the possibility to attach annotations to terms and formulas, which can be used to specify the model behaviors. \cite{vmt-lib-paper}

It is designed with a limited amount of language constructs, aiming for simplicity for anyone interested in implementing the language within their VMT solver:
\begin{itemize}
    \item \textbf{:next name} is used to specify state variables. To define a state variable, two variables are created, one representing the current state and one representing the next state. The next annotation is used to link the next state variable to the current state variable.
    \item \textbf{:init} is used to specify the formula used to constrain the initial states for the system.
    \item \textbf{:trans} is used to specify the formula used to constrain the transitions from each state to the next for the system.
    \item \textbf{:invar-property idx} is used to specify an invariant property to be verified, in LTL it's in the form \begin{math} G \phi \end{math} and requires a formula to always hold.  A unique non-negative integer specifies the index of the property.
    \item \textbf{:live-property idx} is used to specify a live property to be verified, in LTL it's in the form \begin{math} F\ G\ \phi\end{math} and requires a formula to hold infinitely often. A unique non-negative integer specifies the index of the property.
\end{itemize}

An in-depth explanation of the format, including a list of available tools may be found on the VMT-LIB website. \cite{VMT-LIB}

PyVmt modelling system is similar to that of VMT-LIB making converting to and from the format simpler.
This allows for higher interoperability since a model created in PyVmt may be serialized to VMT-LIB and be used in a model checker which isn't supported by the library.

\section{Reading}
PySMT already supports parsing SmtLib2 through the SmtLibParser class.
PyVmt defines a function for reading a script from an input stream called `read', which parses the script and runs through the annotations.
For every NEXT annotation a new state variable is added. Since PyVmt only keeps track of curr state variables the next state one is ignored.
After that, any declaration which was not a curr or next state variable is considered as an input.

To make next state variables work properly in trans constraints and properties, a substituter is employed to replace every instance of a next state variable with the corresponding representation using the Next operator.

Reading an existing VMT-LIB model can have several use-cases:
\begin{enumerate}
    \item Modifying a model by adding state variables or constraints in a programmatic way, or combining it with other models
    \item Analyzing an existing model (e.g. by creating a custom formula walker that reads the constraints, by printing some statistics,\dots)
    \item Running the same VMT-LIB script against multiple solvers, with different combination of options
    \item PySmt's SmtLibParser shows exactly where parsing errors occur, helping debug broken VMT-LIB files. This can be demoed by running \mintinline{bash}{python3 -m pyvmt < some_script.vmt}
\end{enumerate}
\inputminted[firstline=11, lastline=34]{python3}{py/vmtlib_support.py}

\section{Writing}
PySMT already provides printers for SMT-LIB2 supporting two formats: normal and daggified, the latter providing a version that avoids repeating repeated formulae.

The serialize method of the Model produces a fresh symbol for each of the current state variables so that it may use them to replace all of the Next operators which are not supported in VMT-LIB.
To make sure that the replacements work properly, a custom walker named NextPusher is used to push all of the Next operators down to the leaves, leaving Next operators only on Symbols.
Additionally, to replace the unsupported operators the VmtLibSubstituter is used. To be specific it performs a replacement of any Next state variable with the corresponding fresh symbol, leaving the final formula with only supported operators.

As previously mentioned, serializing a model to VMT-LIB is useful whenever trying to use a model checker which is not directly supported by PyVmt, but it can also be a step to use a model checker that doesn't support VMT-LIB in the first place.
Once the model has been serialized to VMT-LIB, several tools are available to further convert the model to a different format, they may be found on the vmt-lib website under the section `Tool Support' \cite{VMT-LIB}, the currently supported formats for conversion are:
\begin{itemize}
    \item btor2
    \item horn
    \item nuXmv
    \item core vmt, excluding language extensions
\end{itemize}

\inputminted[firstline=37, lastline=38]{python3}{py/vmtlib_support.py}

\section{LTL}
PyVmt supports reading LTL-properties thanks to an extension of the SmtLibParser that adds the various operators as interpreted functions. Additionally, LTL operators may be printed using the VmtPrinter and VmtDagPrinter, which respectively extend the SmtPrinter and SmtDagPrinter provided by pySMT. The \begin{math}\phi\ R\ \psi\end{math} operator is not natively supported by VMT-LIB, properties that contain it must first be passed through the VmtLibSubstituter which replaces it with the equivalent \begin{math}\lnot (\lnot \phi\ U \lnot \psi) \end{math}. As mentioned in the previous section this is done automatically while serializing a model.

% LTL removal

