\chapter{Verification modulo theory}

\paragraph*{SMT}
Satisfiability modulo theory is a generalization of the SAT (boolean satisfiability) problem. It involves proving whether a formula can be satisfied by some assignment of the variables. The expressions, which can include lists, arrays, bit vectors, and strings are interpreted within a formal theory. There exists a standard language for defining SMT problems called SMT-LIB \cite{SMT-LIB} and it simplifies interfacing to the solvers, which are the programs developed to decide whether a formula is satisfiable.

\paragraph*{VMT}
Verification modulo theory adds a dynamic aspect to SMT, allowing the specification of transition systems. In VMT, transition systems are defined in a symbolic manner, they're composed of several elements:
\begin{itemize}
    \item State variables
    \item An init constraint
    \item A transition constraint
\end{itemize}
States are therefore not explicitly expressed, rather the assignments to the state variables may be used to encode them.
This has the advantage of allowing for transition systems with an extremely large number of states, and is frequently a more natural way to define their behavior.
The transition between states is regulated by a transition constraint, which is a function between current and next state variables and must be verified during a transition. The set of initial states is also not explicit, initial states must verify the init constraint.


\section{Importance of model checking}
The classical approach for finding and resolving bugs in software usually involves writing tests and code reviews done by other developers.
The safety of a system tested in this manner is not guaranteed since only a limited amount of scenarios can be explored, and subtle bugs may go unnoticed even after peer-review.
A mathematical approach is therefore necessary whenever such guarantees are required, for example when dealing with complex, safety-critical systems where bugs may have severe repercussions and are therefore not acceptable.

For these applications, software may be written utilizing a formal language, allowing for model checking to be applied in order to formally verify some properties corresponding to the specifications.

\section{Some applications}
Many different problems can be solved by using a verification tool, the following paragraphs include a few relevant ones.

\paragraph*{LTL} LTL or Linear Temporal Logic is used to define complex properties over execution sequences of the system.
It works with a fragment of first order logic and adds several operators (X, F, G, U) to introduce the concept of time to our properties.
The semantics of the operators is as follows:
\begin{itemize}
    \item \begin{math} X \phi \end{math}, in the next step \begin{math} \phi \end{math} is verified
    \item \begin{math} F \phi \end{math}, in some future step \begin{math} \phi \end{math} has to be verified
    \item \begin{math} G \phi \end{math}, \begin{math} \phi \end{math} is globally verified
    \item \begin{math} \phi\ R\ \psi \end{math}, \begin{math} \psi \end{math} is verified as long as \begin{math} \phi \end{math} is not verified
\end{itemize}

Combinations of these operators may be used to create classic property types or more complex properties.

\paragraph*{Safety} Safety properties are used to define that the system never reaches states in which a condition we want to avoid is verified, in LTL this can be written as \begin{math}G (\lnot bad)\end{math}.
This verifies that the states which the system can reach is limited to safe ones and that the bad behavior cannot be reached during the execution.

An example of a safety problem is ensuring that it's impossible for the door of a microwave to be open when the device is running:
\begin{math}
    G \lnot (open \land running)
\end{math}.

\paragraph*{Fairness} Fairness specifies that a set of states must be visited infinitely often during execution and is denoted in LTL as \begin{math} G(F(\phi))\end{math}.
Fairness can be used both as a property to be checked or as a constraint that defines how infinite traces of the system should look like.

A problem involving a fairness property is ensuring that a scheduler for an operating system eventually schedules each process, thus not leaving any process to wait infinitely often.

\paragraph*{Liveness} Liveness properties specify that after a while, a property holds forever. It's denoted in LTL as \begin{math} F(G(\phi)) \end{math}.
This kind of property is frequently explained with the notion that something good will eventually happen and relates to the concept of progress.
They're similar to fairness properties, in fact the previous formula is equivalent to \begin{math} \lnot G(F(\lnot \phi))\end{math} meaning that a liveness property may be proven invalid by a trace in which \begin{math} \phi \end{math} is negated infinitely often, which is a fair path for \begin{math}\lnot \phi\end{math}.

\paragraph*{Decision problems} Some complex logic problems involving decisions on an evolving system may be modelled as a transition system.
After that is done, a property can be added specifying that a solution to the original problem may not be found, i.e. \begin{math} G (\lnot solved) \end{math}.
A specialized program may be used to verify whether the property holds, if it doesn't (meaning that a solution to our problem exists), it may print the exact steps required to reach such solution.

A classic problem that can be solved in this manner is the ferryman problem, where a ferryman has to carry across a river several entities (e.g. a cabbage, a wolf, and a sheep) on a boat with a limited capacity, while never leaving certain pairs of entities unattended (e.g. the sheep with the cabbage or the sheep with the wolf).
Once modelled, the solution can be found as a counterexample to the property:
\begin{math}
    G (\exists (entity). \lnot isAcross(entity))
\end{math}.
The resulting counterexample displays which entities have to be carried across the river and back in each step.

\section{The VMT-LIB format}
VMT-LIB is an extension of the SMT2 format and provides a standard interface for defining transition systems by exploiting the possibility to attach annotations to terms and formulas, which can be used to specify the model behaviors. \cite{VMT-LIB}

It is designed with a limited amount of language constructs, aiming for simplicity for anyone interested in implementing the language within their VMT solver:
\begin{itemize}[noitemsep]
    \item \textbf{:next name} is used to specify state variables. To define a state variable, two variables are created, one representing the current state and one representing the next state. The next annotation is used to link the next state variable to the current state variable.
    \item \textbf{:init} is used to specify the formula used to constrain the initial states for the system.
    \item \textbf{:trans} is used to specify the formula used to constrain the transitions from each state to the next for the system.
    \item \textbf{:invar-property idx} is used to specify an invariant property to be verified, in LTL it's in the form \begin{math} G \phi \end{math} and requires a formula to always hold.  A unique non-negative integer specifies the index of the property.
    \item \textbf{:live-property idx} is used to specify a live property to be verified, in LTL it's in the form \begin{math} F\ G\ \phi\end{math} and requires a formula to hold infinitely often. A unique non-negative integer specifies the index of the property.
\end{itemize}
\cite{vmt-lib-paper} %...

% execution paths...

