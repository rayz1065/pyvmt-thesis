\chapter{Other features}

\section{LTL encoding}
LTL properties aren't always supported directly by model checkers, but live properties together with an encoding of the original property into the model may be used as a replacement.
While working on this thesis I implemented two LTL encoding algorithms in PyVmt by using pySMT's formula manipulation tools.

\paragraph*{LTL2SMV encoding}
One of the classic encoding procedures for LTL was proposed in 1994 in a paper titled "Another Look at LTL Model Checking" \cite{Clarke1997}.
This procedure involves creating a tableau associated with the negation of the LTL formula, finding a set of elementary subformulas and for each of them a condition that defines whether that subformula is satisfied (characteristic function, here referred to as sat value).
By composing the model with the tableau it's possible to analyze how the state of the LTL specification changes as steps are performed on the original model.

Elementary subformulae are defined for the LTL operators \begin{math}X\ \phi\end{math} and \begin{math}\phi\ U\ \psi\end{math}, therefore the first step for encoding is normalizing the negated formula through the \mintinline{python3}{LtlRewriter} walker which performs the following substitutions:
\begin{itemize}
    \item \begin{math}\phi\ R\ \psi\end{math} to \begin{math}\lnot(\lnot \phi\ U \lnot \psi)\end{math}
    \item \begin{math}F\ \phi\end{math} to \begin{math}\top\ U\ \phi\end{math}
    \item \begin{math}G\ \phi\end{math} to \begin{math}\lnot (F\ \lnot \phi)\end{math}
\end{itemize}

A specialized formula walker, \mintinline{python3}{LtlEncodingWalker}, is then employed to compute all of the elementary subformulae and the associated sat values:
\begin{itemize}
    \item For \begin{math}X\ \phi\end{math} a fresh symbol \begin{math}EL_{X \phi}\end{math} is created, with \begin{math}sat(X\ \phi) = EL_{X \phi}\end{math}
    \item For \begin{math}\phi\ U\ \psi\end{math} a fresh symbol \begin{math}EL_{X (\phi\ U\ \psi)}\end{math} is created, with \begin{math}sat(\phi\ U\ \psi) = sat(\psi) \lor (sat(\phi) \land EL_{X (\phi\ U\ \psi)})\end{math}
\end{itemize}

To constrain the evolution of the new variables, a transition constraint is added for each of them:

\[ EL_{X \phi} \leftrightarrow sat(\phi)' \]

To ensure that the properties are eventually fulfilled, liveness properties are added to the model.
For every elementary subformula in the shape \begin{math}X (\phi\ U\ \psi)\end{math}, a property \begin{math}\lnot sat(\phi\ U\ \psi) \lor sat(\psi) \end{math} is added.
The properties are then combined into a single liveness property to ensure compatibility with the model checkers, which is negated to return to our original LTL specification.

% Include sample implementation?

\paragraph*{LTL circuit encoding}

% TODO

\section{Merging transition systems}
\paragraph*{Synchronous compositions}
Composing transition systems by means of synchronous composition involves having the two systems evolve by means of transition at the same time.
This differs from asynchronous composition where at each step, exactly one of the systems is chosen to evolve independently of the other.
For symbolic transition systems, synchronous composition means creating a transition system that includes all of the state and input variables of the original systems, and constraining the system so that the initial states are valid initial states for both transition systems, and the transitions are valid transitions for both transition systems.
This can simply be done by means of conjunction between the original constraints.

Merging symbolic transition systems through synchronous composition in PyVmt can be done using the compose function, which takes as input two models and returns the resulting model.
It was decided to keep the functionality as simple as possible, in order to avoid behaviors which the user might not expect like having the variables change to fresh ones as the systems are merged.
For that reason, whenever a state variable and/or an input coincide, they're considered the same variable in the final system.
This can be useful to make the two models communicate by replacing a nondeterministic input variable with a constrained state variable as defined from another model.

\inputminted[firstline=9, lastline=33]{python3}{py/composition.py}

\section{Renaming transition systems}
It may be necessary to rename the variable contained within a model to avoid having an overlap with the variables of another model when using synchronous composition.
PyVmt offers a model renamer to simplify such a process, with several utility functions that implement a specific renaming pattern, while allowing the user to also specify a custom renaming callback by using the rename function.
The patterns which are available act on the prefix and suffix of each of the input and state variables, allowing the addition or replacement of the prefix/suffix.

\inputminted[firstline=9, lastline=41]{python3}{py/renaming.py}

