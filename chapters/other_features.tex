\chapter{Other Features}

\section{\ltl{} Encoding}
\ltl{} properties aren't always supported directly by model checkers, but live properties together with an encoding of the original property into the model may be used as a replacement.
While working on this thesis I implemented two \ltl{} encoding algorithms in \pyvmt{} by using \pysmt{}'s formula manipulation tools.

\paragraph*{\ltltosmv{} encoding.}
One of the classic encoding procedures for \ltl{} was proposed in 1994 in a paper titled "Another Look at \ltl{} Model Checking" \cite{Clarke1997}.
This procedure involves creating a tableau associated with the negation of the \ltl{} formula, finding a set of elementary subformulas and for each of them a condition that defines whether that subformula is satisfied (characteristic function, here referred to as sat value).
By composing the model with the tableau it's possible to analyze how the state of the \ltl{} specification changes as steps are performed on the original model.

Elementary subformulae are defined for the \ltl{} operators \fX{} and \fU{}, therefore the first step for encoding is normalizing the negated formula through the \texttt{LtlRewriter} walker which performs the following substitutions:
\begin{itemize}
    \item \fR{} $\longrightarrow{}$ $\lnot(\lnot \phi \U \lnot \psi)$
    \item \fF{} to $\top \U \phi$
    \item \fG{} to $\lnot (\F \lnot \phi)$
\end{itemize}

A specialized formula walker, \texttt{LtlEncodingWalker}, is then employed to compute all of the elementary subformulae and the associated sat values:
\begin{itemize}
    \item For \fX{} a fresh symbol $\mathrm{EL}_{\fX}$ is created, with $\mathrm{sat}(\fX) = EL_{\fX}$
    \item For \fU{} a fresh symbol $\mathrm{EL}_{X (\fU)}$ is created, with $\mathrm{sat}(\fU) = sat(\psi) \lor (\mathrm{sat}(\phi) \land \mathrm{EL}_{X (\fU)})$
\end{itemize}

To constrain the evolution of the new variables, a transition constraint is added for each of them:

\[ \mathrm{EL}_{\fX} \leftrightarrow (\mathrm{sat}(\phi))' \]

To ensure that the properties are eventually fulfilled, liveness properties are added to the model.
For every elementary subformula in the shape \begin{math}X (\fU)\end{math}, a property \begin{math}\lnot \mathrm{sat}(\fU) \lor \mathrm{sat}(\psi) \end{math} is added.
The properties are then combined into a single liveness property to ensure compatibility with the model checkers, which is negated to return to our original \ltl{} specification.

% Include sample implementation?

\paragraph*{\ltl{} circuit encoding}

A different approach for the encoding was presented in "A circuit Approach to \ltl{} Model Checking" \cite{LTLCircuits}.

\section{Merging Transition Systems}
\paragraph*{Synchronous compositions.}
Composing transition systems by means of synchronous composition involves having the two systems evolve through transitions at the same time.
This differs from asynchronous composition where at each step, exactly one of the systems is chosen to evolve independently of the other.
For symbolic transition systems, synchronous composition means creating a transition system that includes all of the state and input variables of the original systems, and constraining the system so that the initial states are valid initial states for both transition systems, and the transitions are valid transitions for both transition systems.
This can simply be done by means of conjunction between the original constraints.

Merging symbolic transition systems through synchronous composition in \pyvmt{} can be done using the \texttt{compose} function, which takes as input two models and returns the resulting model.
It was decided to keep the functionality as simple as possible, in order to avoid behaviors which the user might not expect like having the variables change to \texttt{FreshSymbol}s as the systems are merged.
For that reason, whenever a state variable and/or an input coincide, they're considered the same variable in the final system.
This can be useful to make the two models communicate by replacing a nondeterministic input variable with a constrained state variable as defined from another model.

\begin{listing}
    \label{alg:composition}
    \inputmintedpy{py/composition.py}{9}{35}
    \caption{\texttt{model\_b} is a counter which increments based on a non-deterministic variable \texttt{a}. Since \texttt{a} may always be 0, the property $\F (\G (\mathrm{counter} > 10))$ is unsafe.
    Composing the model with \texttt{model\_a} replaces the input \texttt{a} with the state variable from \texttt{model\_a}, making the previous property safe.}
\end{listing}

\section{Renaming Transition Systems}
It may be necessary to rename the variable contained within a model to avoid having an overlap with the variables of another model when using synchronous composition.
\pyvmt{} offers a model renamer to simplify such a process, with several utility functions that implement a specific renaming pattern.
It's also possible for the user to specify a custom renaming callback by using the \texttt{rename} function.
The patterns which are available act on the prefix and suffix of each of the input and state variables, allowing the addition or replacement of the prefix/suffix.


\begin{listing}[H]
    \label{alg:renaming}
    \inputmintedpy{py/renaming.py}{9}{41}
    \caption{Through renaming, 3 counter models are created, each with a different limit.
    The property $\G (\sum_\textrm{i}^3 \mathrm{model[i].a} < 6)$ is then checked and a counterexample of length 11 is found, when the counters synchronize and their sum reaches 6.}
\end{listing}

