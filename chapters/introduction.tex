\chapter*{Introduction}
\label{introduction}

\paragraph*{Context and motivation}
\pyvmt{} was created by me as part of a formative internship at \FBK{}. It's an extension of an existing project which was also created in the foundation, \pysmt{}, which offers a solver-agnostic formula manipulation interface.
Several factors motivate the creation for an extension:
\begin{itemize}
  \item the creation of specific tools and functions which are commonly used in model verification
  \item the extension of the existing \smtlib{} parser to extract the information relating to the model and its properties written in \vmtlib{} format
  \item the addition of support for model checkers to offer an experience similar to \pysmt{} while dealing with verification problems
\end{itemize}

\paragraph*{What can \pyvmt{} do?}
\pyvmt{} is a \python{} library that enables the user to manage VMT models by reading and writing code in the \vmtlib{} format, modifying models by adding variables, constraints, properties, or with some higher level function such as renaming and synchronous composition. It offers several model checkers as backend for verification, making it simpler for the user to choose several of them and compare their performance.

\paragraph*{Techniques used}
\pyvmt{} is written in \python{}, it was developed using a continuous integration approach, utilizing \github{} actions as a tool to verify non-regression after each update.
Tests are run using the \pytest{} test suite and are mostly composed of unit tests which aim to cover most of the library's source code.
Most of the documentation is present in the source code as doc-strings so that they can easily be looked up while using an IDE. An external reference is also available and can be generated using sphinx.
After all the tests pass, the new version of the library is automatically uploaded as a package to \pypi{} so that any user can use it in their own project.

\paragraph*{Results reached}
To verify the functionality of \pyvmt{}, I collected several benchmarks and ran them against the available solvers. The results from these experiments show a promising support from the backends to deal with most of the problems within their supported theories.

