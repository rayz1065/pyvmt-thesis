\chapter*{Abstract}
\label{abstract}

\addcontentsline{toc}{chapter}{Abstract}

\paragraph*{Context and motivation}
PyVmt was created by me as part of a formative internship at Fondazione Bruno Kessler. It's an extension of an existing project which was also created in the foundation, pySMT, which offers a solver-agnostic formula manipulation interface.
Several factors motivate the creation for an extension:
\begin{itemize}
  \item the creation of specific tools and functions which are commonly used in model verification
  \item the extension of the existing SMT-LIB parser to extract the information relating to the model and its properties written in VMT-LIB format
  \item the addition of support for model checkers to offer an experience similar to pySMT while dealing with verification problems
\end{itemize}

\paragraph*{What can PyVmt do?}
PyVmt is a python library that enables the user to manage VMT models by reading and writing code in the VMT-LIB format, modifying models by adding variables, constraints, properties, or with some higher level function such as renaming and synchronous composition. It offers several model checkers as backend for verification, making it simpler for the user to choose several of them and compare their performance.

\paragraph*{Techniques used}
PyVmt is written in Python, it was developed using a continuous integration approach, utilizing Github actions as a tool to verify non-regression after each update.
Tests are run using the pytest test suite and are mostly composed of unit tests which aim to cover most of the library's source code.
Most of the documentation is present in the source code as doc-strings so that they can easily be looked up while using an IDE. An external reference is also available and can be generated using sphinx.
After all the tests pass, the new version of the library is automatically uploaded as a package to PyPi so that any user can use it in their own project.

\paragraph*{Results reached}
To verify the functionality of PyVmt, I collected several benchmarks and ran them against the available solvers. The results from these experiments show a promising support from the backends to deal with most of the problems within their supported theories.
